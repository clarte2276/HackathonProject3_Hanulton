{"ast":null,"code":"// import React, { useEffect, useState } from 'react';\n// import { useParams } from 'react-router-dom';\n// import axios from 'axios';\n// import './Chatroom.css';\n// const Chatroom = () => {\n//   const { userId, receiverId } = useParams();\n//   const [messages, setMessages] = useState([]);\n//   const [newMessage, setNewMessage] = useState('');\n//   const [roomMessages, setRoomMessages] = useState([]);\n//   // 주기적으로 메시지를 가져오는 함수\n//   const fetchMessages = async () => {\n//     try {\n//       console.log(`Fetching messages for sender ${userId} to receiver ${receiverId}`);\n//       const response = await axios.get(`/chat/chatroom/${userId}/to/${receiverId}/messages`);\n//       console.log('Fetched messages:', response.data);\n//       if (Array.isArray(response.data)) {\n//         setMessages(response.data);\n//       } else {\n//         console.error('Fetched data is not an array:', response.data);\n//         // 메세지를 받아올 때 isMyMessage 속성 설정\n//         const processedMessages = response.data.map((msg) => ({\n//           ...msg,\n//           isMyMessage: msg.receiver_id === parseInt(receiverId) && msg.sender_id === parseInt(userId),\n//         }));\n//         setMessages(processedMessages);\n//       }\n//     } catch (error) {\n//       console.error('Error fetching messages:', error);\n//     }\n//   };\n//   useEffect(() => {\n//     // 초기 메시지 로드\n//     fetchMessages();\n//     // 1초마다 fetchMessages 함수를 호출\n//     const interval = setInterval(fetchMessages, 100);\n//     // 컴포넌트가 언마운트될 때 인터벌 정리\n//     return () => clearInterval(interval);\n//   }, [userId, receiverId]);\n//   useEffect(() => {\n//     if (Array.isArray(messages) && messages.length) {\n//       setRoomMessages(\n//         messages.filter(\n//           (msg) =>\n//             (msg.receiver_id === parseInt(roomId) && msg.sender_id === parseInt(my_roomid)) ||\n//             (msg.receiver_id === parseInt(my_roomid) && msg.sender_id === parseInt(roomId))\n//         )\n//       );\n//     }\n//   }, [messages, roomId, my_roomid]);\n//   const handleSendMessage = async () => {\n//     if (newMessage.trim() === '') return;\n//     try {\n//       const sender_id = parseInt(my_roomid);\n//       const receiver_id = parseInt(roomId); // 현재 대화 상대방의 roomId로 사용됩니다.\n//       console.log('Sending message:', {\n//         sender_id,\n//         receiver_id,\n//         content: newMessage,\n//       });\n//       // 백엔드에 새 메시지 보내기\n//       const response = await axios.post(`/chatrooms/${my_roomid}/to/${roomId}/messages`, {\n//         sender_id,\n//         receiver_id,\n//         content: newMessage,\n//       });\n//       console.log('Response:', response);\n//       //     // 메시지를 성공적으로 보낸 후 메시지 목록 업데이트\n//       //     setMessages((prevMessages) => [\n//       //       ...prevMessages,\n//       //       {\n//       //         sender_id,\n//       //         receiver_id,\n//       //         content: newMessage,\n//       //         isMyMessage: true,\n//       //       },\n//       //     ]);\n//       //     setNewMessage('');\n//       //   } catch (error) {\n//       //     console.error('Error sending message:', error);\n//       //   }\n//       // };\n//       // 메시지를 성공적으로 보낸 후 메시지 목록 업데이트\n//       const newMsg = {\n//         sender_id,\n//         receiver_id,\n//         content: newMessage,\n//         isMyMessage: true,\n//       };\n//       // 기존 메시지에 추가하지 않고 새 배열로 설정하여 유지\n//       setMessages((prevMessages) => [...prevMessages, newMsg]);\n//       setNewMessage('');\n//     } catch (error) {\n//       console.error('Error sending message:', error);\n//     }\n//   };\n//   return (\n//     <div className=\"chattingRoom\">\n//       <div className=\"chatroom-messages\">\n//         {roomMessages.map((msg, index) => (\n//           <div key={index} className={msg.isMyMessage ? 'my-message-container' : 'other-message-container'}>\n//             <p className={msg.isMyMessage ? 'my-message' : 'other-message'}>{msg.content}</p>\n//           </div>\n//         ))}\n//       </div>\n//       <div className=\"msgsendItem\">\n//         <div className=\"inputMessage\">\n//           <input\n//             type=\"text\"\n//             value={newMessage}\n//             onChange={(e) => setNewMessage(e.target.value)}\n//             placeholder=\"Typing your message\"\n//           />\n//         </div>\n//         <button onClick={handleSendMessage} className=\"sendmessageBtn\">\n//           Send\n//         </button>\n//       </div>\n//     </div>\n//   );\n// };\n// export default Chatroom;","map":{"version":3,"names":[],"sources":["C:/Users/atwod/OneDrive/바탕 화면/동국대 폴더/백엔드 공부/HackathonProject3_Hanulton/front-end/src/components/chat/Chatroom.js"],"sourcesContent":["// import React, { useEffect, useState } from 'react';\r\n// import { useParams } from 'react-router-dom';\r\n// import axios from 'axios';\r\n// import './Chatroom.css';\r\n\r\n// const Chatroom = () => {\r\n//   const { userId, receiverId } = useParams();\r\n//   const [messages, setMessages] = useState([]);\r\n//   const [newMessage, setNewMessage] = useState('');\r\n//   const [roomMessages, setRoomMessages] = useState([]);\r\n\r\n//   // 주기적으로 메시지를 가져오는 함수\r\n//   const fetchMessages = async () => {\r\n//     try {\r\n//       console.log(`Fetching messages for sender ${userId} to receiver ${receiverId}`);\r\n//       const response = await axios.get(`/chat/chatroom/${userId}/to/${receiverId}/messages`);\r\n//       console.log('Fetched messages:', response.data);\r\n//       if (Array.isArray(response.data)) {\r\n//         setMessages(response.data);\r\n//       } else {\r\n//         console.error('Fetched data is not an array:', response.data);\r\n//         // 메세지를 받아올 때 isMyMessage 속성 설정\r\n//         const processedMessages = response.data.map((msg) => ({\r\n//           ...msg,\r\n//           isMyMessage: msg.receiver_id === parseInt(receiverId) && msg.sender_id === parseInt(userId),\r\n//         }));\r\n\r\n//         setMessages(processedMessages);\r\n//       }\r\n//     } catch (error) {\r\n//       console.error('Error fetching messages:', error);\r\n//     }\r\n//   };\r\n\r\n//   useEffect(() => {\r\n//     // 초기 메시지 로드\r\n//     fetchMessages();\r\n\r\n//     // 1초마다 fetchMessages 함수를 호출\r\n//     const interval = setInterval(fetchMessages, 100);\r\n\r\n//     // 컴포넌트가 언마운트될 때 인터벌 정리\r\n//     return () => clearInterval(interval);\r\n//   }, [userId, receiverId]);\r\n\r\n//   useEffect(() => {\r\n//     if (Array.isArray(messages) && messages.length) {\r\n//       setRoomMessages(\r\n//         messages.filter(\r\n//           (msg) =>\r\n//             (msg.receiver_id === parseInt(roomId) && msg.sender_id === parseInt(my_roomid)) ||\r\n//             (msg.receiver_id === parseInt(my_roomid) && msg.sender_id === parseInt(roomId))\r\n//         )\r\n//       );\r\n//     }\r\n//   }, [messages, roomId, my_roomid]);\r\n\r\n//   const handleSendMessage = async () => {\r\n//     if (newMessage.trim() === '') return;\r\n//     try {\r\n//       const sender_id = parseInt(my_roomid);\r\n//       const receiver_id = parseInt(roomId); // 현재 대화 상대방의 roomId로 사용됩니다.\r\n\r\n//       console.log('Sending message:', {\r\n//         sender_id,\r\n//         receiver_id,\r\n//         content: newMessage,\r\n//       });\r\n\r\n//       // 백엔드에 새 메시지 보내기\r\n//       const response = await axios.post(`/chatrooms/${my_roomid}/to/${roomId}/messages`, {\r\n//         sender_id,\r\n//         receiver_id,\r\n//         content: newMessage,\r\n//       });\r\n\r\n//       console.log('Response:', response);\r\n\r\n//       //     // 메시지를 성공적으로 보낸 후 메시지 목록 업데이트\r\n//       //     setMessages((prevMessages) => [\r\n//       //       ...prevMessages,\r\n//       //       {\r\n//       //         sender_id,\r\n//       //         receiver_id,\r\n//       //         content: newMessage,\r\n//       //         isMyMessage: true,\r\n//       //       },\r\n//       //     ]);\r\n//       //     setNewMessage('');\r\n//       //   } catch (error) {\r\n//       //     console.error('Error sending message:', error);\r\n//       //   }\r\n//       // };\r\n\r\n//       // 메시지를 성공적으로 보낸 후 메시지 목록 업데이트\r\n//       const newMsg = {\r\n//         sender_id,\r\n//         receiver_id,\r\n//         content: newMessage,\r\n//         isMyMessage: true,\r\n//       };\r\n\r\n//       // 기존 메시지에 추가하지 않고 새 배열로 설정하여 유지\r\n//       setMessages((prevMessages) => [...prevMessages, newMsg]);\r\n//       setNewMessage('');\r\n//     } catch (error) {\r\n//       console.error('Error sending message:', error);\r\n//     }\r\n//   };\r\n\r\n//   return (\r\n//     <div className=\"chattingRoom\">\r\n//       <div className=\"chatroom-messages\">\r\n//         {roomMessages.map((msg, index) => (\r\n//           <div key={index} className={msg.isMyMessage ? 'my-message-container' : 'other-message-container'}>\r\n//             <p className={msg.isMyMessage ? 'my-message' : 'other-message'}>{msg.content}</p>\r\n//           </div>\r\n//         ))}\r\n//       </div>\r\n//       <div className=\"msgsendItem\">\r\n//         <div className=\"inputMessage\">\r\n//           <input\r\n//             type=\"text\"\r\n//             value={newMessage}\r\n//             onChange={(e) => setNewMessage(e.target.value)}\r\n//             placeholder=\"Typing your message\"\r\n//           />\r\n//         </div>\r\n//         <button onClick={handleSendMessage} className=\"sendmessageBtn\">\r\n//           Send\r\n//         </button>\r\n//       </div>\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default Chatroom;\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}